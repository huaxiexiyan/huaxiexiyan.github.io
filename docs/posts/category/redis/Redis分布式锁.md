---
title: Redis分布式锁
---
# 为什么需要分布式锁
单机场景下用的都是本地锁，针对的仅仅是一个jvm进程所管理的资源。当单体应用部署了多份的时候，一个jvm进程中本地锁是无法影响到另一个jvm进程的本地锁的，这样是无法保证资源的独占的。所以分布式锁应运而生。
# 一个靠谱的分布式锁需要具备哪些条件
首先需要考虑一个合格的分布式锁需要具备哪些条件。
一个锁需要具备的基本功能
1、独占性：任何时候都仅能有一个线程获取该锁。这是任何一个锁最基础的功能，毕竟锁就是为了解决资源竞争产生的不一致问题。
2、不乱抢：当前线程加的锁，只能有当前线程来解锁，也不能去unlock其它线程加的锁。
3、可重入性：在当前线程中，如果已经获取了该锁，之后将可以自动再次获取这个锁。
在分布式环境需要额外考虑的问题
1、防止死锁：要能杜绝死锁，要有兜底方案，例如能支持撤销操作或者可以超时自动释放
2、高可用：性能要好，能支撑高并发请求，不能因为某节点不可用，就导致获取锁或者释放失败

# 如果自己来实现一个分布式锁该如何做
自然是围绕了如何实现上面靠谱的分布式锁具备的条件了。
## 前置准备工作
1、选择外部存储介质
因为需要让不同的jvm进程都能访问到存放锁的资源点，那么就需要依赖jvm外部的存储介质了。一般来说就是 数据库（关系型或nosql）、微服务里的配置中心（支持多个服务来读存数据）。那么这里就先用目前最常用的nosql数据库 Redis 为例来实现了。
2、代码实现规范
分布式锁必然有多种实现方式，那自然应该是基于接口来编程，那么直接实现jdk中的lock接口就是最好的方式。
## 测试准备
准备一个多实例，支持并发请求的测试环境，来验证是否代码是否通过。

## 分步来实现分布式锁应具备的功能
1、独占性
只需要在存储介质上留下个锁标记即可，如果其他线程能查询到这个标识，那就说明该资源已经上锁，否则则表示无锁，可以上锁。


# 有什么成熟的解决方案

# 需要注意些什么
