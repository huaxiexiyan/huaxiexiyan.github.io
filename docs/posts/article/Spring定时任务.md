---
title: Spring定时任务
---

# 初认识

## 基本用于

## 三种触发器

### 实际运行一下

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

/**
 * @author xiyan
 * @date 2023/7/5 14:36
 */
@Slf4j
@EnableScheduling
@Component
public class DemoScheduledTest {


    /**
     * 固定延迟时间
     * 间隔 5s ，执行 3s、实际间隔8s
     * 2023-07-06 17:36:05.068
     * 2023-07-06 17:36:13.091
     * 2023-07-06 17:36:21.109
     * 2023-07-06 17:36:29.134
     * 2023-07-06 17:36:37.149
     * <p>
     * 间隔 5s ，执行 5s、实际间隔10s
     * 2023-07-05 14:38:46.182
     * 2023-07-05 14:38:56.196
     * 2023-07-05 14:39:06.210
     * 2023-07-05 14:39:16.235
     * 2023-07-05 14:39:26.244
     * <p>
     * 间隔 5s ，执行 7s、实际间隔12s
     * 2023-07-05 14:45:02.764
     * 2023-07-05 14:45:14.775
     * 2023-07-05 14:45:26.796
     * 2023-07-05 14:45:38.814
     * 2023-07-05 14:45:50.830
     * <p>
     * 下次执行时间=上次执行时间+(fixedDelay时间+执行耗时)
     */
    @Scheduled(fixedDelay = 5000)
    public void test1() {
        try {
            log.info("test1方法执行=====>>>>");
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 固定间隔时间
     * 间隔5s、执行3s、实际间隔5s
     * 2023-07-06 18:00:11.362
     * 2023-07-06 18:00:16.352
     * 2023-07-06 18:00:21.358
     * 2023-07-06 18:00:26.355
     * 2023-07-06 18:00:31.364
     * <p>
     * 间隔 5s ，执行 5s、实际间隔5s
     * 2023-07-05 14:40:39.180
     * 2023-07-05 14:40:44.185
     * 2023-07-05 14:40:49.200
     * 2023-07-05 14:40:54.212
     * 2023-07-05 14:40:59.226
     * <p>
     * 间隔5s，执行7s、实际间隔7s
     * 2023-07-05 14:41:45.559
     * 2023-07-05 14:41:52.567
     * 2023-07-05 14:41:59.581
     * 2023-07-05 14:42:06.588
     * 2023-07-05 14:42:13.593
     * <p>
     * 下次执行时间=上次执行时间+ max(fixedRate, 执行耗时)
     */
    @Scheduled(fixedRate = 5000)
    public void test2() {
        try {
            log.info("test2方法执行=====>>>>");
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * cron表达式
     * <p>
     * 间隔5s、执行3s、实际间隔5s
     * 2023-07-06 17:55:10.015
     * 2023-07-06 17:55:15.001
     * 2023-07-06 17:55:20.014
     * 2023-07-06 17:55:25.007
     * 2023-07-06 17:55:30.008
     * <p>
     * 间隔 5s ，执行 5s、实际间隔10s
     * 2023-07-06 17:49:55.008
     * 2023-07-06 17:50:05.014
     * 2023-07-06 17:50:15.000
     * 2023-07-06 17:50:25.004
     * 2023-07-06 17:50:35.005
     * <p>
     * 间隔5s，执行7s、实际间隔10s
     * 2023-07-06 17:51:55.016
     * 2023-07-06 17:52:05.008
     * 2023-07-06 17:52:15.001
     * 2023-07-06 17:52:25.010
     * 2023-07-06 17:52:35.014
     * <p>
     * 下次执行时间=如果到达定时时间，上一个任务已完成，将会执行，否则会跳过
     */
    @Scheduled(cron = "0/5 * * * * ?")
    public void test3() {
        try {
            log.info("test3方法执行=====>>>>");
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }

}
```

### 为什么会这样



# 运行原理

# 拓展应用