const e=JSON.parse('{"key":"v-2c289f4d","path":"/posts/article/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.html","title":"雪花算法","lang":"zh-CN","frontmatter":{"title":"雪花算法","description":"snowflake 分布式id生成算法的有很多种，Twitter的雪花算法（SnowFlake）就是其中经典的一种。 SnowFlake算法的优点： 生成ID时不依赖于数据库，完全在内存生成，高性能高可用。 容量大，每秒可生成几百万ID。 SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？同一毫秒的ID数量 = 1024 * 4096 = 4194304 所有生成的id按时间趋势递增，后续插入数据库的索引树的时候，性能较高。 整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）","head":[["meta",{"property":"og:url","content":"https://blog.catguild.cn/posts/article/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"雪乃の猫"}],["meta",{"property":"og:title","content":"雪花算法"}],["meta",{"property":"og:description","content":"snowflake 分布式id生成算法的有很多种，Twitter的雪花算法（SnowFlake）就是其中经典的一种。 SnowFlake算法的优点： 生成ID时不依赖于数据库，完全在内存生成，高性能高可用。 容量大，每秒可生成几百万ID。 SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？同一毫秒的ID数量 = 1024 * 4096 = 4194304 所有生成的id按时间趋势递增，后续插入数据库的索引树的时候，性能较高。 整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-14T05:26:21.000Z"}],["meta",{"property":"article:author","content":"雪乃の猫"}],["meta",{"property":"article:modified_time","content":"2023-08-14T05:26:21.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"雪花算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-14T05:26:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"雪乃の猫\\",\\"url\\":\\"https://blog.catguild.cn\\"}]}"]]},"headers":[{"level":2,"title":"概述","slug":"概述","link":"#概述","children":[]},{"level":2,"title":"Talk is cheap, show you the code","slug":"talk-is-cheap-show-you-the-code","link":"#talk-is-cheap-show-you-the-code","children":[]},{"level":2,"title":"代码理解","slug":"代码理解","link":"#代码理解","children":[{"level":3,"title":"位运算基础","slug":"位运算基础","link":"#位运算基础","children":[]},{"level":3,"title":"用位运算计算n个bit能表示的最大数值","slug":"用位运算计算n个bit能表示的最大数值","link":"#用位运算计算n个bit能表示的最大数值","children":[]},{"level":3,"title":"用mask防止溢出","slug":"用mask防止溢出","link":"#用mask防止溢出","children":[]},{"level":3,"title":"用位运算汇总结果","slug":"用位运算汇总结果","link":"#用位运算汇总结果","children":[]}]},{"level":2,"title":"支持反推数据","slug":"支持反推数据","link":"#支持反推数据","children":[]}],"git":{"createdTime":1691990781000,"updatedTime":1691990781000,"contributors":[{"name":"xiyan","email":"liuzhi0621@gmail.com","commits":1}]},"readingTime":{"minutes":6.36,"words":1908},"filePathRelative":"posts/article/雪花算法.md","localizedDate":"2023年8月14日","excerpt":"<h1> snowflake</h1>\\n<p>分布式id生成算法的有很多种，Twitter的雪花算法（SnowFlake）就是其中经典的一种。</p>\\n<p>SnowFlake算法的优点：</p>\\n<ul>\\n<li>生成ID时不依赖于数据库，完全在内存生成，高性能高可用。</li>\\n<li>容量大，每秒可生成几百万ID。\\n<ul>\\n<li>SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？同一毫秒的ID数量 = 1024 * 4096 = 4194304</li>\\n</ul>\\n</li>\\n<li>所有生成的id按时间趋势递增，后续插入数据库的索引树的时候，性能较高。</li>\\n<li>整个分布式系统内不会产生重复id（因为有<code>datacenterId</code>和<code>workerId</code>来做区分）</li>\\n</ul>","autoDesc":true}');export{e as data};
