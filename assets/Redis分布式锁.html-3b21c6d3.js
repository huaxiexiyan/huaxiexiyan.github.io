import{_ as a,W as e,X as h,a2 as r}from"./framework-6199cc12.js";const d={},i=r('<h1 id="为什么需要分布式锁" tabindex="-1"><a class="header-anchor" href="#为什么需要分布式锁" aria-hidden="true">#</a> 为什么需要分布式锁</h1><p>单机场景下用的都是本地锁，针对的仅仅是一个jvm进程所管理的资源。当单体应用部署了多份的时候，一个jvm进程中本地锁是无法影响到另一个jvm进程的本地锁的，这样是无法保证资源的独占的。所以分布式锁应运而生。</p><h1 id="一个靠谱的分布式锁需要具备哪些条件" tabindex="-1"><a class="header-anchor" href="#一个靠谱的分布式锁需要具备哪些条件" aria-hidden="true">#</a> 一个靠谱的分布式锁需要具备哪些条件</h1><p>首先需要考虑一个合格的分布式锁需要具备哪些条件。 一个锁需要具备的基本功能 1、独占性：任何时候都仅能有一个线程获取该锁。这是任何一个锁最基础的功能，毕竟锁就是为了解决资源竞争产生的不一致问题。 2、不乱抢：当前线程加的锁，只能有当前线程来解锁，也不能去unlock其它线程加的锁。 3、可重入性：在当前线程中，如果已经获取了该锁，之后将可以自动再次获取这个锁。 在分布式环境需要额外考虑的问题 1、防止死锁：要能杜绝死锁，要有兜底方案，例如能支持撤销操作或者可以超时自动释放 2、高可用：性能要好，能支撑高并发请求，不能因为某节点不可用，就导致获取锁或者释放失败</p><h1 id="如果自己来实现一个分布式锁该如何做" tabindex="-1"><a class="header-anchor" href="#如果自己来实现一个分布式锁该如何做" aria-hidden="true">#</a> 如果自己来实现一个分布式锁该如何做</h1><p>自然是围绕了如何实现上面靠谱的分布式锁具备的条件了。</p><h2 id="前置准备工作" tabindex="-1"><a class="header-anchor" href="#前置准备工作" aria-hidden="true">#</a> 前置准备工作</h2><p>1、选择外部存储介质 因为需要让不同的jvm进程都能访问到存放锁的资源点，那么就需要依赖jvm外部的存储介质了。一般来说就是 数据库（关系型或nosql）、微服务里的配置中心（支持多个服务来读存数据）。那么这里就先用目前最常用的nosql数据库 Redis 为例来实现了。 2、代码实现规范 分布式锁必然有多种实现方式，那自然应该是基于接口来编程，那么直接实现jdk中的lock接口就是最好的方式。</p><h2 id="测试准备" tabindex="-1"><a class="header-anchor" href="#测试准备" aria-hidden="true">#</a> 测试准备</h2><p>准备一个多实例，支持并发请求的测试环境，来验证是否代码是否通过。</p><h2 id="分步来实现分布式锁应具备的功能" tabindex="-1"><a class="header-anchor" href="#分步来实现分布式锁应具备的功能" aria-hidden="true">#</a> 分步来实现分布式锁应具备的功能</h2><p>1、独占性 只需要在存储介质上留下个锁标记即可，如果其他线程能查询到这个标识，那就说明该资源已经上锁，否则则表示无锁，可以上锁。</p><h1 id="有什么成熟的解决方案" tabindex="-1"><a class="header-anchor" href="#有什么成熟的解决方案" aria-hidden="true">#</a> 有什么成熟的解决方案</h1><h1 id="需要注意些什么" tabindex="-1"><a class="header-anchor" href="#需要注意些什么" aria-hidden="true">#</a> 需要注意些什么</h1>',14),n=[i];function t(s,c){return e(),h("div",null,n)}const l=a(d,[["render",t],["__file","Redis分布式锁.html.vue"]]);export{l as default};
