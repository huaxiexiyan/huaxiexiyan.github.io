import{_ as a,W as e,X as r,a2 as p}from"./framework-6199cc12.js";const t={},n=p('<h1 id="线程中断机制" tabindex="-1"><a class="header-anchor" href="#线程中断机制" aria-hidden="true">#</a> 线程中断机制</h1><h1 id="locksupport类" tabindex="-1"><a class="header-anchor" href="#locksupport类" aria-hidden="true">#</a> LockSupport类</h1><p>简介：用于创建锁和其他同步类的基本线程阻塞原语</p><p>该类与使用它的每个线程关联一个许可证（在Semaphore类的意义上）。如果许可证可用，将立即返回park，并在此过程中消费；否则可能会阻止。如果尚未提供许可，则致电unpark获取许可（与Semaphore不同，许可证不会累积，最多只有一个）</p><p>主要api：park与unpark方法，需要成对使用。</p><p>park：除非许可证可用，否则禁用当前线程以进行线程调度。【作用：阻塞线程】</p><p>unaprk：如果给定线程尚不可用，则为其提供许可。【作用：解除阻塞线程】</p><p>底层调用的是unsafe类，</p><p>使用场景：</p><h1 id="线程阻塞唤醒的方法" tabindex="-1"><a class="header-anchor" href="#线程阻塞唤醒的方法" aria-hidden="true">#</a> 线程阻塞唤醒的方法</h1><p>有3种方式</p><p>1、使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</p><p>2、使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程</p><p>3、 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞线程</p><h1 id="线程等待唤醒机制" tabindex="-1"><a class="header-anchor" href="#线程等待唤醒机制" aria-hidden="true">#</a> 线程等待唤醒机制</h1>',15),o=[n];function h(i,c){return e(),r("div",null,o)}const s=a(t,[["render",h],["__file","线程中断.html.vue"]]);export{s as default};
